{
    "has <command>": {
        "prefix": "has",
        "body": "has ${1:command}",
        "description": "Return 0 if the command is available. Return 1 otherwise"
    },
    "expand_path <rel_path> [<relative_to>]": {
        "prefix": "expand_path",
        "body": "expand_path ${1:rel_path}",
        "description": "Outputs the absolute path of rel_path relative to relative_to or the current directory"
    },
    "dotenv [<dotenv_path>]": {
        "prefix": "dotenv",
        "body": "dotenv ${1:.env}",
        "description": "Loads a “.env” file into the current environment"
    },
    "dotenv_if_exists [<dotenv_path>]": {
        "prefix": "dotenv_if_exists",
        "body": "dotenv_if_exists ${1:.env}",
        "description": "Loads a “.env” file into the current environment, but only if it exists"
    },
    "user_rel_path <abs_path>": {
        "prefix": "user_rel_path",
        "body": "user_rel_path ${1:abs_path}",
        "description": "Transforms an absolute path abs_path into a user-relative path if possible"
    },
    "find_up <filename>": {
        "prefix": "find_up",
        "body": "find_up ${1:filename}",
        "description": "Outputs the path of filename when searched from the current directory up to /. Returns 1 if the file has not been found"
    },
    "source_env <file_or_dir_path>": {
        "prefix": "source_env",
        "body": "source_env ${1:path}",
        "description": "Loads another .envrc either by specifying its path or filename"
    },
    "source_env_if_exists <filename>": {
        "prefix": "source_env_if_exists",
        "body": "source_env_if_exists ${1:filename}",
        "description": "Loads another .envrc, but only if it exists"
    },
    "env_vars_required <varname> [<varname> ...]": {
        "prefix": "env_vars_required",
        "body": "env_vars_required ${1:varname}",
        "description": "Logs error for every variable not present in the environment or having an empty value"
    },
    "source_up [<filename>]": {
        "prefix": "source_up",
        "body": "source_up ${1:filename}",
        "description": "Loads another .envrc if found with the find_up command. Returns 1 if no file is found"
    },
    "source_up_if_exists [<filename>]": {
        "prefix": "source_up_if_exists",
        "body": "source_up_if_exists ${1:filename}",
        "description": "Loads another .envrc if found with the find_up command. If one is not found, nothing happens"
    },
    "source_url <url> <integrity-hash>": {
        "prefix": "source_url",
        "body": "source_url ${1:url} ${2:integrity-hash}",
        "description": "Loads another script from the given url. Before loading it it will check the integrity using the provided integrity-hash"
    },
    "fetchurl <url> [<integrity-hash>]": {
        "prefix": "fetchurl",
        "body": "fetchurl ${1:url}",
        "description": "Fetches the given url onto disk and outputs its path location on stdout"
    },
    "direnv_apply_dump <file>": {
        "prefix": "direnv_apply_dump",
        "body": "direnv_apply_dump ${1:file}",
        "description": "Loads the output of direnv dump that was stored in a file"
    },
    "direnv_load [<command-generating-dump-output>]": {
        "prefix": "direnv_load",
        "body": "direnv_load ${1:command-generating-dump-output}",
        "description": "Applies the environment generated by running argv as a command. This is useful for adopting the environment of a child process - cause that process to run “direnv dump” and then wrap the results with direnv_load"
    },
    "PATH_add <path>": {
        "prefix": "PATH_add",
        "body": "PATH_add ${1:path}",
        "description": "Prepends the expanded path to the PATH environment variable. It prevents a common mistake where PATH is replaced by only the new path"
    },
    "MANPATH_add <path>": {
        "prefix": "MANPATH_add",
        "body": "MANPATH_add ${1:path}",
        "description": "Prepends the expanded path to the MANPATH environment variable. It takes care of man-specific heuritic"
    },
    "path_add <varname> <path>": {
        "prefix": "path_add",
        "body": "path_add ${1:varname} ${2:path}",
        "description": "Works like PATH_add except that it’s for an arbitrary varname"
    },
    "PATH_rm <pattern> [<pattern> ...]": {
        "prefix": "PATH_rm",
        "body": "PATH_rm ${1:pattern}",
        "description": "Removes directories that match any of the given shell patterns from the PATH environment variable. Order of the remaining directories is preserved in the resulting PATH"
    },
    "load_prefix <prefix_path>": {
        "prefix": "load_prefix",
        "body": "load_prefix ${1:prefix_path}",
        "description": "Expands some common path variables for the given prefix_path prefix. This is useful if you installed something in the prefix_path using ./configure --prefix=$prefix_path && make install and want to use it in the project"
    },
    "semver_search <directory> <folder_prefix> <partial_version>": {
        "prefix": "semver_search",
        "body": "semver_search ${1:directory} ${2:folder_prefix} ${3:partial_version}",
        "description": "Search a directory for the highest version number in SemVer format (X.Y.Z)"
    },
    "layout <type>": {
        "prefix": "layout",
        "body": "layout ${1:type}",
        "description": "A semantic dispatch used to describe common project layouts"
    },
    "layout go": {
        "prefix": "layoutgo",
        "body": "layout go",
        "description": "Adds “$(direnv_layout_dir)/go” to the GOPATH environment variable. And also adds “$PWD/bin” to the PATH environment variable"
    },
    "layout julia": {
        "prefix": "layoutjulia",
        "body": "layout julia",
        "description": "Sets the JULIA_PROJECT environment variable to the current directory"
    },
    "layout node": {
        "prefix": "layoutnode",
        "body": "layout node",
        "description": "Adds “$PWD/node_modules/.bin” to the PATH environment variable"
    },
    "layout php": {
        "prefix": "layoutphp",
        "body": "layout php",
        "description": "Adds “$PWD/vendor/bin” to the PATH environment variable"
    },
    "layout perl": {
        "prefix": "layoutperl",
        "body": "layout perl",
        "description": "Setup environment variables required by perl’s local::lib See http://search.cpan.org/dist/local-lib/lib/local/lib.pm for more details"
    },
    "layout pipenv": {
        "prefix": "layoutpipenv",
        "body": "layout pipenv",
        "description": "Similar to layout python, but uses Pipenv to build a virtualenv from the Pipfile located in the same directory. The path can be overridden by the PIPENV_PIPFILE environment variable"
    },
    "layout pyenv [<version> ...]": {
        "prefix": "layoutpyenv",
        "body": "layout pyenv ${1:version}",
        "description": "Similar to layout python, but uses pyenv to build a virtualenv with the specified Python interpreter version. Multiple versions may be specified separated by spaces; please refer to the pyenv documentation for more information"
    },
    "layout python [<python_exe>]": {
        "prefix": "layoutpython",
        "body": "latyout python ${1:python_exe}",
        "description": "Creates and loads a virtualenv environment under $PWD/.direnv/python-$python_version. This forces the installation of any egg into the project’s sub-folder"
    },
    "layout python3": {
        "prefix": "layoutpython3",
        "body": "layout python3",
        "description": "A shortcut for layout python python3"
    },
    "layout ruby": {
        "prefix": "layoutruby",
        "body": "layout ruby",
        "description": "Sets the GEM_HOME environment variable to $PWD/.direnv/ruby/RUBY_VERSION. This forces the installation of any gems into the project’s sub-folder. If you’re using bundler it will create wrapper programs that can be invoked directly instead of using the bundle exec prefix"
    },
    "use <program_name> [<version>]": {
        "prefix": "use",
        "body": "use ${1:program} ${2:version}",
        "description": "A semantic command dispatch intended for loading external dependencies into the environment"
    },
    "use julia <version>": {
        "prefix": "usejulia",
        "body": "use julia ${1:version}",
        "description": "Loads the specified Julia version"
    },
    "use rbenv": {
        "prefix": "userbenv",
        "body": "use rbenv",
        "description": "Loads rbenv which add the ruby wrappers available on the PATH"
    },
    "use nix [...]": {
        "prefix": "usenix",
        "body": "use nix ${1:...}",
        "description": "Load environment variables from nix-shell"
    },
    "use flake [<installable>]": {
        "prefix": "useflake",
        "body": "use flake ${1:installable}",
        "description": "Load the build environment of a derivation similar to nix develop"
    },
    "use guix [...]": {
        "prefix": "useguix",
        "body": "use guix ${1:...}",
        "description": "Load environment variables from guix shell"
    },
    "rvm [...]": {
        "prefix": "rvm",
        "body": "rvm ${1...}",
        "description": "Should work just like in the shell if you have rvm installed"
    },
    "use node [<version>]": {
        "prefix": "usenode",
        "body": "use node ${1:version}",
        "description": "Loads the specified NodeJS version into the environment"
    },
    "use vim [<vimrc_file>]": {
        "prefix": "usevim",
        "body": "use vim ${1:vimrc}",
        "description": "Prepends the specified vim script (or .vimrc.local by default) to the DIRENV_EXTRA_VIMRC environment variable"
    },
    "watch_file <path> [<path> ...]": {
        "prefix": "watch_file",
        "body": "watch_file ${1:path}",
        "description": "Adds each file to direnv’s watch-list. If the file changes direnv will reload the environment on the next prompt"
    },
    "direnv_version <version_at_least>": {
        "prefix": "direnv_version",
        "body": "direnv_version ${1:version_at_least}",
        "description": "Checks that the direnv version is at least old as version_at_least. This can be useful when sharing an .envrc and to make sure that the users are up to date"
    },
    "strict_env [<command> ...]": {
        "prefix": "strict_env",
        "body": "strict_env ${1:command}",
        "description": "Turns on shell execution strictness"
    },
    "unstrict_env [<command> ...]": {
        "prefix": "unstrict_env",
        "body": "unstrict_env ${1:command}",
        "description": "Turns off shell execution strictness"
    },
    "on_git_branch [<branch_name>]": {
        "prefix": "on_git_branch",
        "body": "on_git_branch ${1:branch}",
        "description": "Returns 0 if within a git repository with given branch_name. If no branch name is provided, then returns 0 when within any branch"
    }
}
